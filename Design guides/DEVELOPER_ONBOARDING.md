# The Commons - Developer Onboarding Guide

*Auto-generated by Claude Code*

## Quick Start (5 minutes)

### Prerequisites
- Node.js (v14+ recommended)
- Basic understanding of JavaScript, WebSockets, and isometric games

### Running the Project
```bash
# Clone and setup
cd the-commons-clean
npm install

# Start the server
node server.js

# Open browser to localhost:3000
# Click "Start Solo Game" to begin
```

### First Look Around
1. **Beer Hall Lobby** - Pre-game setup (player name, city name)
2. **Main Game** - Isometric city view with sidebar panels
3. **Governance Modal** - Budget allocation and voting system
4. **Building Placement** - Click parcels to build structures

## Architecture Overview (15 minutes)

### System Design Philosophy
The Commons follows a **server-authoritative** multiplayer architecture:
- **Server**: Authoritative game state, economic calculations, transaction validation
- **Client**: Optimistic UI, real-time rendering, user input handling
- **Communication**: WebSocket-based real-time synchronization

### Key Components

```
┌─────────────────┐    ┌──────────────────┐    ┌─────────────────┐
│   Beer Hall     │    │   Main Server    │    │  Economic       │
│   Lobby         │────│   (server.js)    │────│  Engine         │
│   (Pre-game)    │    │                  │    │  (Authoritative)│
└─────────────────┘    └──────────────────┘    └─────────────────┘
                                │
                                ▼
                       ┌──────────────────┐
                       │   Game Clients   │
                       │   - game.js      │
                       │   - ui-manager   │
                       │   - governance   │
                       │   - rendering    │
                       └──────────────────┘
```

### Data Flow Pattern
```
User Action → Client Validation → WebSocket → Server Validation → State Update → Broadcast → All Clients Update
```

## Core Systems Deep Dive (30 minutes)

### 1. Economic Engine (`server-economic-engine-v2.js`)
**Purpose**: The heart of the simulation - all economic calculations happen here.

**Key Concepts**:
- **JEEFHH System**: Jobs, Environment, Education, Food, Housing, Health supply/demand
- **CARENS Scoring**: Culture, Affordability, Resilience, Environment, Noise, Safety (-100 to +100)
- **Monthly Cycles**: Economic calculations run on timer intervals
- **Server-Authoritative**: All economic formulas calculated server-side

**Key Methods**:
```javascript
// Main economic cycle
processTransaction(transaction)  // Handles all player actions
calculateSupplyDemand()         // JEEFHH calculations
calculateLivabilityScore()      // CARENS calculations
broadcastGameState()            // Sends updates to all clients
```

### 2. Governance System (`governance-v3.js`)
**Purpose**: Democratic budget allocation and Land Value Tax (LVT) voting.

**Key Concepts**:
- **Voting Points**: Players start with 2, gain 2 more each month
- **Budget Categories**: Housing, Jobs, Environment, Education, Food, Health
- **LVT Voting**: Players vote to increase/decrease land value tax rates
- **Real-Time Updates**: Allocation changes broadcast immediately

**Key Methods**:
```javascript
adjustAllocation(category, delta)  // Change budget allocation
adjustLVTVote(direction)          // Vote on tax rates
updateUI()                        // Refresh governance display
```

### 3. Rendering System (`rendering-system-v2.js`)
**Purpose**: Optimized isometric graphics rendering.

**Key Concepts**:
- **Isometric Projection**: 2D sprites arranged in 3D-looking perspective
- **Layered Rendering**: Tiles → Buildings → Overlays → UI
- **Performance Optimization**: Only redraw when necessary

### 4. WebSocket Communication
**Purpose**: Real-time multiplayer synchronization.

**Message Types**:
- `GAME_STATE`: Complete game state synchronization
- `ECONOMIC_TRANSACTION`: Player actions (building, voting, etc.)
- `GOVERNANCE_VOTE`: Budget and tax voting
- `CHAT_MESSAGE`: Player communication

## Development Workflows (20 minutes)

### Adding a New Building Type

1. **Update Building Data** (`buildings.js` or via CSV upload):
```javascript
{
  "id": "new_building",
  "name": "New Building",
  "cost": 1000,
  "category": "housing",
  "impacts": {
    "housing": { "supply": 5 },
    "environment": { "demand": 2 }
  }
}
```

2. **Add Sprite Assets** (if needed):
```javascript
// In rendering-system-v2.js
const buildingSprites = {
  new_building: 'path/to/sprite.png'
}
```

3. **Test Economic Impact**:
```javascript
// Economic engine automatically handles new buildings
// Test supply/demand changes in governance modal
```

### Adding a New Governance Category

1. **Update Economic Engine** (`server-economic-engine-v2.js`):
```javascript
// Add to budget calculation logic
const budgetCategories = {
  // existing categories...
  newCategory: {
    name: 'New Category',
    allocation: 0
  }
}
```

2. **Update Governance UI** (`governance-v3.js`):
```javascript
// Add to category list
const categories = ['housing', 'jobs', 'environment', 'education', 'food', 'health', 'newCategory'];
```

3. **Update Budget Display** (`ui-manager.js`):
```javascript
// Add category to financial overview
```

### Debugging Common Issues

**Problem**: Client/Server State Mismatch
```javascript
// Check WebSocket messages in browser DevTools
// Look for GAME_STATE messages
// Compare client.gameState vs server state
```

**Problem**: Economic Calculations Seem Wrong
```javascript
// Check server console for economic engine logs
// Verify supply/demand calculations
// Check building impact data
```

**Problem**: Governance Voting Not Working
```javascript
// Verify player has voting points available
// Check GOVERNANCE_VOTE WebSocket messages
// Ensure server broadcasts governance updates
```

## File Structure Guide (10 minutes)

### Core Game Files
```
├── server.js                    # Main server + WebSocket hub
├── server-room-manager.js       # Game room lifecycle
├── server-economic-engine-v2.js # Economic calculations (AUTHORITATIVE)
├── index.html                   # Main game interface
├── game.js                      # Primary client + rendering
├── economic-client-v2.js        # Server synchronization
├── ui-manager.js                # UI coordination
├── governance-v3.js             # Democratic voting system
└── buildings.js                 # Building definitions
```

### Specialized Systems
```
├── rendering-system-v2.js       # Isometric graphics
├── tooltip-system-v2.js         # Context information
├── action-marketplace-v2.js     # Player trading
├── building-system.js           # Construction logic
├── context-menu-system.js       # Right-click menus
└── beer-hall-lobby.js           # Pre-game lobby
```

### Utilities & Support
```
├── csv-uploader.js              # Data import
├── event-cleanup-manager.js     # Memory management
├── client-state-auditor.js      # Debugging tool
├── city-name-generator.js       # Random names
└── config.js                    # Configuration
```

## Development Environment Setup (10 minutes)

### Recommended Tools
- **IDE**: VS Code with JavaScript extensions
- **Browser**: Chrome with DevTools for WebSocket debugging
- **Testing**: Manual testing with multiple browser tabs (multiplayer)

### Development Commands
```bash
# Start development server
node server.js

# Test multiplayer locally
# Open multiple tabs to localhost:3000
# Each tab = separate player

# View WebSocket messages
# Chrome DevTools → Network → WS tab
```

### Configuration
```javascript
// config.js - Adjust game parameters
const CONFIG = {
  economicUpdateInterval: 30000,  // 30 seconds = 1 game month
  startingCash: 10000,
  maxPlayers: 4
}
```

## Best Practices (10 minutes)

### Code Style
1. **Server-Authoritative**: Never trust client data, always validate server-side
2. **Real-Time First**: Use WebSocket broadcasts, not polling
3. **Performance**: Minimize DOM updates, batch canvas redraws
4. **Multiplayer Safe**: Test with multiple browser tabs

### Architecture Patterns
1. **Economic Engine**: Add new features to server-economic-engine-v2.js
2. **UI Updates**: Use ui-manager.js for coordinated interface changes
3. **WebSocket Messages**: Follow existing type patterns (see WEBSOCKET_ARCHITECTURE.md)
4. **State Management**: Client state should mirror server state

### Testing Approach
1. **Solo Testing**: Start with single-player functionality
2. **Multiplayer Testing**: Open multiple browser tabs
3. **Edge Cases**: Test disconnection/reconnection scenarios
4. **Performance**: Monitor WebSocket message frequency

## Common Gotchas (5 minutes)

1. **Isometric Coordinates**: Screen coordinates ≠ game grid coordinates
2. **WebSocket Timing**: Race conditions between messages
3. **Economic Formulas**: Complex interdependencies in supply/demand
4. **State Synchronization**: Client optimistic updates vs server authority
5. **Memory Leaks**: Event listeners accumulate over time

## Next Steps

1. **Read**: `SYSTEM_ARCHITECTURE.md` for deeper system understanding
2. **Read**: `WEBSOCKET_ARCHITECTURE.md` for communication patterns
3. **Explore**: Start with small changes to building data or UI
4. **Build**: Try adding a simple new feature end-to-end
5. **Test**: Always test multiplayer scenarios with multiple browser tabs

## Getting Help

- **Architecture Questions**: Reference SYSTEM_ARCHITECTURE.md
- **WebSocket Issues**: Reference WEBSOCKET_ARCHITECTURE.md
- **Economic Formulas**: Check server-economic-engine-v2.js comments
- **UI Problems**: Look at existing patterns in ui-manager.js
- **Debugging**: Use client-state-auditor.js for state analysis

---

*Total Onboarding Time: ~2 hours*
*Generated: $(date)*